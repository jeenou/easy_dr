use jlrs::prelude::*;
use std::path::PathBuf;
//use jlrs::memory::target::frame::GcFrame;
//use jlrs::data::managed::value::ValueResult;
use crate::juliainterface::{juliainterface};
use jlrs::error::JlrsError;

/*
pub fn call_my_fu(p: i32) -> Result<{}}, Box<JlrsError>> {
    // Initialize the Julia runtime
    let mut frame = StackFrame::new();
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }

    let _x = julia.scope(|mut frame| {
    
        let n_p = Value::new(&mut frame, p); 
                  
        let module = "Structures"; 
        let function = "my_fu"; 
        let result = juliainterface::_call1(&mut frame, module, function, n_p).unwrap().into_jlrs_result().into::<>()?;    
    
        result
        
    }).expect("result is an error");

}
*/

pub fn _test(da1: i64, da2: i64, da3: i64, da4: i64) {
    let mut frame = StackFrame::new();
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    let mut result:  Result<Value<'_, '_>, Box<JlrsError>>;

    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.
    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }
    
    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {
    
        let d1 = Value::new(&mut frame, da1);
        let d2 = Value::new(&mut frame, da2); 
        let d3 = Value::new(&mut frame, da3); 
        let d4 = Value::new(&mut frame, da4);  
                  
        let module = "Structures"; 
        let function = "print_message"; 
        let result = juliainterface::_call4(&mut frame, module, function, []).unwrap().into_jlrs_result();    
    
        result
        
    }).expect("result is an error");
    

}

pub fn _temporals<T>() {
    let mut frame = StackFrame::new(); 
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.

    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }

    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {


        let timestamps = JuliaString::new(&mut frame, "2023-06-20T10:30:00").as_value();


    // Convert the Rust vector into a Julia array

    let temporals = Array::new_for(frame.as_extended_target(), (3,), timestamps);
    //let temporals = Array::from_string(frame.as_extended_target(), timestamps, (5,));

    match temporals {
        Ok(value1) => {
            let module = "Structures"; 
            let _temporal_function = "create_temporals";
            //as_value can convert array to value!!
            let _result_node = juliainterface::_call1(&mut frame, module, _temporal_function, value1.as_value()).unwrap();
            match _result_node {
                Ok(value2) => {
                    let _function = "add_delay";
                    let _convert_result = juliainterface::_call1(&mut frame, module, _function, value2).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Added delay!"),
                        Err(error) => println!("Error adding delay: {:?}", error),
                    }
                }
                Err(error) => println!("Error creating temporals: {:?}", error),
            }
        }
        Err(error) => println!("Error creating temporals: {:?}", error),
    }

        
        Ok(()) 
        
    }).expect("result is an error");

}

pub fn _create_node(name: &str, is_commodity: bool, is_market: bool) {
    let mut frame = StackFrame::new();
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);
    let mut inflow = false;
    let mut is_state = false;
    let mut is_res = false;
    
    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.
    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }
    
    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {
    
        let n_name = JuliaString::new(&mut frame, name).as_value(); 
        let n_commodity = Value::new(&mut frame, is_commodity); 
        let n_market = Value::new(&mut frame, is_market); 
        
    
            
        let module = "Structures"; 
        let function = "create_node"; 
        let _result_node = juliainterface::_call3(&mut frame, module, function, n_name, n_commodity, n_market).unwrap();
        
    
        //Convert node to commodity if is_commodity is true

        //Ottaa parametrina Noden, ok
        if is_commodity {
            match _result_node {
                Ok(value) => {
                    let _convert_function = "convert_to_commodity";
                    let _convert_result = juliainterface::_call1(&mut frame, module, _convert_function, value).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Node converted to commodity"),
                        Err(error) => println!("Error converting node to commodity: {:?}", error),
                    }
                }
                Err(error) => println!("Error creating node: {:?}", error),
            }
        }

        else if is_market {
            match _result_node {
                Ok(value) => {
                    let _convert_function = "convert_to_market";
                    let _convert_result = juliainterface::_call1(&mut frame, module, _convert_function, value).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Node converted to commodity"),
                        Err(error) => println!("Error converting node to commodity: {:?}", error),
                    }
                }
                Err(error) => println!("Error creating node: {:?}", error),
            }
        }

        //funktio ottaa inputtina sekä Noden että TimeSeries
        /*
        else if inflow {
            match _result_node {
                Ok(value) => {
                    let _convert_function = "add_inflow";
                    let _convert_result = _call2(&mut frame, module, _convert_function, value, TIMESERIES).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Added inflow to node"),
                        Err(error) => println!("Error adding inflow to node: {:?}", error),
                    }
                }
                Err(error) => println!("Error adding inflow: {:?}", error),
            }
        }
        */

        /*
        tähän funktioon lähetetään jokin Predicer.State, joka pitää luoda luultavasti ensin, katso onko siihen funktiota
        if is_state {
            match _result_node {
                Ok(value) => {
                    let _convert_function = "add_state";
                    let _convert_result = _call2(&mut frame, module, _convert_function, value, STATE).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Added inflow to node"),
                        Err(error) => println!("Error adding inflow to node: {:?}", error),
                    }
                }
                Err(error) => println!("Error adding inflow: {:?}", error),
            }
        }
        */

        //Ottaa parametrina Noden, ok
        else if is_res {
            match _result_node {
                Ok(value) => {
                    let _convert_function = "add_node_to_reserve";
                    let _convert_result = juliainterface::_call1(&mut frame, module, _convert_function, value).unwrap();
                }
                Err(error) => println!("Error adding inflow: {:?}", error),
            }
        }
    
         Ok(())
        
    }).expect("result is an error");
    

}

/*
pub fn _create_process<T>(name: &str, conversion: i32, delay: f32, min_load: f64, max_load: f64, eff: f64) {
    let mut frame = StackFrame::new(); 
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.
    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }

    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {

        let p_name = JuliaString::new(&mut frame, name).as_value();
        let p_conversion = Value::new(&mut frame, conversion); 
        let p_delay = Value::new(&mut frame, delay);  
        
        if conversion == 1 {
            let _convert_function = "create_Process";
            let _result_process = _call3(&mut frame, module, _convert_function, p_name, p_conversion, p_delay).unwrap();
            match _result_process {
                Ok(value) => {

                    let p_min_load = Value::new(&mut frame, min_load);
                    let p_max_load = Value::new(&mut frame, max_load);

                    let _function_1 = "add_load_limits";
                    let _convert_result = _call3(&mut frame, module, _function_1, value, p_min_load, p_max_load).unwrap();
                    match _convert_result {
                        Ok(value) => {

                            if is_cf {
                                //Process, TimeSeries, is_fixed
                                let _function2 = "add_cf";
                                let _result = _call1(&mut frame, module, _function, value).unwrap();
                                match _convert_result {
                                    Ok(_) => println!("Added cf!"),
                                    Err(error) => println!("Error adding delay: {:?}", error),
                                }
                            }
                        }
                        Err(error) => println!("Error creating temporals: {:?}", error),
                    }

                    let _function_2 = "add_eff";
                    let _convert_result = _call3(&mut frame, module, _function_2, value, p_min_load, p_max_load).unwrap();

                }
                Err(error) => println!("Error creating process: {:?}", error),
            }   
        }

        else if conversion == 2 {
            let _convert_function = "TransferProcess";
            let _result_process = _call1(&mut frame, module, _convert_function, p_name).unwrap();
            match _result_process {
                Ok(value) => {
                    let _convert_function = "add_node_to_reserve";
                    let _convert_result = _call1(&mut frame, module, _convert_function, value).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Added inflow to node"),
                        Err(error) => println!("Error adding inflow to node: {:?}", error),
                    }
                }
                Err(error) => println!("Error adding inflow: {:?}", error),
            }   
        }

        else if conversion == 3 {
            let _convert_function = "MarketProcess";
            let _result_process = _call1(&mut frame, module, _convert_function, p_name).unwrap();
            match _result_process {
                Ok(value) => {
                    let _convert_function = "add_node_to_reserve";
                    let _convert_result = _call1(&mut frame, module, _convert_function, value).unwrap();
                    match _convert_result {
                        Ok(_) => println!("Added inflow to node"),
                        Err(error) => println!("Error adding inflow to node: {:?}", error),
                    }
                }
                Err(error) => println!("Error adding inflow: {:?}", error),
            }  
        }
        
    }).expect("result is an error");

}

*/

pub fn _create_nodegroup<T>(name: &str, member: &str) {
    let mut frame = StackFrame::new(); 
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.
    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }

    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {

        let ng_name = JuliaString::new(&mut frame, name).as_value();
        let ng_member = JuliaString::new(&mut frame, member).as_value();  
        

            
        let module = "Structures"; 
        let function = "create_NodeGroup"; 
        let _result_node = juliainterface::_call2(frame, module, function, ng_name, ng_member);
        Ok(()) 
        
    }).expect("result is an error");

}

pub fn _create_processgroup<T>(name: &str, member: &str) {
    let mut frame = StackFrame::new(); 
    let mut pending = unsafe { RuntimeBuilder::new().start().expect("Could not init Julia") };
    let mut julia = pending.instance(&mut frame);

    // Include some custom code defined in MyModule.jl.
    // This is safe because the included code doesn't do any strange things.
    unsafe {
        let path = PathBuf::from("structures.jl");
        if path.exists() {
            julia.include(path).expect("Could not include file");
        } else {
            julia
                .include("src/Predicer/src/structures.jl")
                .expect("Could not include file");
        }
    }

    // An extended target provides a target for the result we want to return and a frame for
    // temporary data.
    let _x = julia.scope(|mut frame| {

        let pg_name = JuliaString::new(&mut frame, name).as_value();
        let pg_member = JuliaString::new(&mut frame, member).as_value();  
        

            
        let module = "Structures"; 
        let function = "create_ProcessGroup"; 
        let _result_node = juliainterface::_call2(frame, module, function, pg_name, pg_member);
        Ok(()) 
        
    }).expect("result is an error");

}